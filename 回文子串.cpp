// 给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。
// 回文字符串 是正着读和倒过来读一样的字符串。
// 子字符串 是字符串中的由连续字符组成的一个序列。
// 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。
#include <string>
#include <vector>
using namespace std;
/*我自己第一时间想到的额动态规划是这样的，相比暴力就是记录下了中间值，速度快点，但应该还是很慢
dp[i][j]表示 i 到 j 的字符串能不能构成回文串,那么dp[i][j] = dp[i +1][j - 1] && (s[i] == s[j])
*/
/*动态规划，Manacher算法！Manacher算法也可以求解最长回文子串
用f(i)表示以s的第i位为回文中心，可以扩展出的最大回文半径（包含了s[i]），那么f(i)-1就是以i为中心的最大回文串长度。
Manacher要求维护当前最大的回文的右端点rm以及这个回文右端点对应的回文中心im。我们需要顺序遍历s。
假设当前遍历的下标为i。我们知道在求解f(i)之前我们应当已经得到了从[1,i+1]所有的f，
并且当前已经有了一个最大回文右端点rm以及它对应的回文中心im。
初始化f(i)：
    如果i<=rm，i比当前最大回文串的右端点小，说明i被包含在当前最大回文子串内，假设j是i关于当前最大回文中心的对称位置j=2*im-i;
    可以得到f(i)至少=min{f(j),rm-i+1}，rm-i+1表示i到边界值，如果f(j)在边界内，则f(j)与f(i)肯定是对称的，如果f(j)超出当前边界，
    则取rm-i+1，因为超过边界的部分还需要进一步确定才行。
    如果i>rm，i比当前最大回文串的右端点大，那就先初始化f(i)=1
中心扩展：
    做完初始化后，可以在s[i+f(i)-1]=s[i-f(i)+1]的前提下，继续扩展这个区间。
    需要注意的是不能让下标越界，有一个很简单的办法，就是在开头加一个 $，并在结尾加一个 !，
    这样开头和结尾的两个字符一定不相等，循环就可以在这里终止。
*/
class Solution
{
public:
    int countSubstrings(string s)
    {
        string t = "$#";
        for (const auto &ch : s)
        {
            t += ch;
            t += '#';
        }
        t += '!'; //保证首尾一定不同
        int n = t.size();
        vector<int> f(n);
        int iMax = 0, rMax = 0, ans = 0; // iMax代表当前最大回文的中心，rMax代表当前最大回文的半径,结果
        for (size_t i = 1; i < n; i++)
        {
            f[i] = i < rMax ? min(f[2 * iMax - i], static_cast<int>(rMax - i + 1)) : 1;
            while (t[i + f[i]] == t[i - f[i]])
            {
                ++f[i];
            }
            ans += (f[i] / 2);
            //动态维护iMax和rMax
            if (i + f[i] - 1 > rMax)
            {
                iMax = i;
                rMax = i + f[i] - 1;
            }
        }
        return ans;
    }
};
